 Alignment Principles (must stay true)

  1. Keep NanoClaw core as a small, understandable host orchestrator (src/index.ts, src/ipc.ts, src/group-queue.ts, src/container-runner.ts).
  2. Keep Claude Agent SDK TypeScript as the runtime harness for NanoClaw orchestration.
  3. Implement your Andy/Jarvis workflow as a skillized layer, not a broad core fork.
  4. Preserve OS/container isolation and least-privilege mounts/tokens.
  5. Enforce behavior with contracts and state transitions, not prompt text alone.

  Target Operating Model

  1. Andy-bot (Haiku): personal assistant + monitoring.
  2. Andy-Developer (Sonnet): planner, dispatcher, reviewer, escalation owner.
  3. Jarvis workers (OpenCode free model, pre-baked): bounded execution agents only.
  4. Single canonical run lifecycle: queued -> running -> review_requested -> rework -> done|failed.
  5. Canonical run_id generated by Andy-Developer and preserved end-to-end.

  Comprehensive Plan

  1. Architecture and Governance (P0)

  - Write one ADR: “Claude SDK orchestrator + OpenCode worker execution tier.”
  - Define hard invariants: run_id, branch naming, required artifacts, retry semantics.
  - Define explicit non-goals: no replacement of NanoClaw core harness, no ad-hoc per-group behavior.

  2. Skillized Delivery Model (P0)

  - Create one umbrella skill first: enable-jarvis-orchestrator.
  - Bundle role docs, dispatch contract, worker policy, review protocol, and rollout checks.
  - Only split into sub-skills after behavior stabilizes for at least 2 release cycles.

  3. Worker Container Standardization (P0)

  - Pre-bake OpenCode CLI/runtime into worker image.
  - Ship pinned opencode.json with fixed free model and strict agent/tool/task permissions.
  - Pre-bake worker skills/workflow docs in container paths the worker always loads.
  - Add deterministic health check command for worker runtime readiness.

  4. Dispatch Contract and State Machine (P0)

  - Enforce JSON schema at ingress (src/ipc.ts) with strict reject-on-invalid behavior.
  - Required fields: run_id, task_type, input, repo, branch, acceptance_tests, output_contract.
  - Normalize retry policy: same run_id is same logical run with bounded retry attempts.
  - Align DB state with contract and fix current run-id/duplicate semantics drift.

  5. Andy-Developer Prompting System (P0)

  - Add task-class templates: analyze, implement, fix, refactor, test, release.
  - Include “free-model optimized” template rules:
  - short objective
  - tight scope paths
  - explicit constraints
  - explicit verification commands
  - mandatory structured output payload
  - Add escalation rubric: when to keep work in Sonnet path instead of worker path.

  6. Review Loop and PR Workflow (P1)

  - Enforce branch convention jarvis-<feature>.
  - Require worker completion artifacts before review_requested:
  - commit SHA
  - changed file list
  - test output summary
  - PR URL or explicit no-PR reason
  - Andy-Developer performs review and emits rework instructions tied to same run_id.

  7. Security and Compliance Hardening (P1)

  - Scope GitHub token permissions per repo and branch protections.
  - Restrict worker mounts to only required paths.
  - Separate sensitive tasks from free-model path using policy tags.
  - Document data-retention caveat for any free/beta model usage.

  8. Observability and Operations (P1)

  - Add per-run audit record: timestamps, state transitions, retries, usage, reviewer.
  - Add failure taxonomy: schema error, tool failure, test fail, timeout, policy violation.
  - Add operational playbook for stuck runs, deadletters, and worker saturation.

  9. Test and Quality Gates (P0/P1)

  - Contract tests: payload validation and rejection paths.
  - Idempotency tests: duplicate/retry behavior by run_id.
  - Parallel isolation tests: two workers, no cross-group leakage.
  - Regression tests: non-Jarvis groups unaffected.
  - End-to-end tests: dispatch -> branch -> PR/review -> done.

  10. Rollout Strategy (P0/P1/P2)

  - P0 canary: 1 worker, low-risk tasks only.
  - P1 expansion: 2 workers, parallel bounded tasks, mandatory review.
  - P2 steady-state: dynamic routing by task complexity and queue pressure.
  - Keep rollback switch: disable worker dispatch while preserving core chat/scheduler behavior.

  Core Change Budget (to preserve NanoClaw philosophy)

  1. Core code changes only for generic primitives:

  - contract validation
  - state persistence
  - safe orchestration hooks

  2. Workflow-specific policy in skill/docs/config layer.
  3. No large feature sprawl in core message loop.

  Definition of Done

  1. Worker tasks are reproducible and auditable by run_id.
  2. Andy-Developer reliably dispatches/reviews with measurable lower token cost.
  3. Non-Jarvis baseline behavior remains unchanged.
  4. All P0 tests pass and canary stability is demonstrated over multiple runs.

  Immediate Next Execution Sequence

  1. Freeze ADR + invariants.
  2. Build enable-jarvis-orchestrator skill package skeleton.
  3. Implement/validate dispatch schema + state machine.
  4. Bake OpenCode worker config/image.
  5. Run canary test matrix and iterate before expanding scope.